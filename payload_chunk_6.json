[{"path": "backend/requirements.txt", "content": "fastapi\nuvicorn\naiohttp\nsse-starlette\npydantic\n"}, {"path": "backend/run_server.bat", "content": "@echo off\ncd /d \"%~dp0\"\necho Starting OpenWrt Manager Backend...\npython main.py\nif %errorlevel% neq 0 (\n    echo Backend crashed with code %errorlevel%\n    pause\n)\n"}, {"path": "backend/scanner.py", "content": "import asyncio\nimport aiohttp\nimport urllib.parse\nfrom typing import Dict, List\n\n# ============================================================================\n# Configuration from original openwrt_manager.py\n# ============================================================================\n\nCREDENTIALS_LIST = [\n    {\"username\": \"root\", \"password\": \"password\"},\n    {\"username\": \"root\", \"password\": \"admin\"},\n    {\"username\": \"admin\", \"password\": \"admin\"},\n    {\"username\": \"ubnt\", \"password\": \"ubnt\"},\n    {\"username\": \"root\", \"password\": \"123456\"},\n    {\"username\": \"root\", \"password\": \"password123\"}, # Added common variation\n    {\"username\": \"admin\", \"password\": \"password\"},\n]\n\nLOGIN_PATHS = [\n    \"/cgi-bin/luci\",\n    \"/cgi-bin/luci/admin\",\n    \"/\",  # Added root as fallback\n]\n\nFIELD_NAME_VARIANTS = [\n    {\"username\": \"luci_username\", \"password\": \"luci_password\"},\n    {\"username\": \"username\", \"password\": \"password\"},\n    {\"username\": \"auth_username\", \"password\": \"auth_password\"},\n]\n\n# ============================================================================\n# Core Logic\n# ============================================================================\n\nasync def check_openwrt(target_url, timeout=10) -> Dict:\n    \"\"\"\n    Robust OpenWrt detection ported from LoginManager.detect_login\n    \"\"\"\n    # Normalize URL\n    if not target_url.startswith((\"http://\", \"https://\")):\n        target_url = f\"http://{target_url}\"\n    \n    # Common headers to mimic browser\n    headers = {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\"\n    }\n\n    try:\n        # Use a single session for all attempts on this target\n        async with aiohttp.ClientSession(\n            timeout=aiohttp.ClientTimeout(total=timeout),\n            headers=headers,\n            connector=aiohttp.TCPConnector(ssl=False) # Important: Ignore SSL errors\n        ) as session:\n            \n            # 1. Iterate through Login Paths\n            for login_path in LOGIN_PATHS:\n                full_login_url = f\"{target_url.rstrip('/')}{login_path}\"\n                \n                try:\n                    # Initial GET to check availability & get cookies/tokens\n                    async with session.get(full_login_url) as response:\n                        if response.status not in [200, 401, 403]:\n                            continue # Path not valid\n                        \n                        # Consume body\n                        await response.read()\n\n                    # 2. Iterate Credentials\n                    for cred in CREDENTIALS_LIST:\n                        username = cred[\"username\"]\n                        password = cred[\"password\"]\n\n                        # 3. Iterate Field Variants\n                        for field_variant in FIELD_NAME_VARIANTS:\n                            form_data = {\n                                field_variant[\"username\"]: username,\n                                field_variant[\"password\"]: password\n                            }\n\n                            try:\n                                async with session.post(full_login_url, data=form_data, allow_redirects=False) as post_response:\n                                    # Logic from original app: Check cookies and redirects for success\n                                    cookies = post_response.cookies\n                                    has_sysauth = any('sysauth' in str(cookie.key) for cookie in cookies.values())\n                                    is_redirect = post_response.status in [302, 303]\n\n                                    if has_sysauth or is_redirect:\n                                        # SUCCESS!\n                                        return {\n                                            \"address\": target_url,\n                                            \"status\": \"success\",\n                                            \"username\": username,\n                                            \"password\": password,\n                                            \"details\": f\"{login_path} | {username}\"\n                                        }\n                                    \n                                    # Fail fast for this credential if not 404/500\n                                    if post_response.status not in [404, 500]:\n                                        break # Password wrong, try next credential (skip other field variants)\n\n                            except Exception:\n                                continue # Try next VARIANT\n\n                except Exception:\n                   continue # Try next PATH\n\n            # If loop finishes without success\n            return {\n                \"address\": target_url,\n                \"status\": \"failed\",\n                \"details\": \"Login Failed\"\n            }\n\n    except asyncio.TimeoutError:\n         return {\"address\": target_url, \"status\": \"failed\", \"details\": \"Timeout\"}\n    except aiohttp.ClientConnectorError:\n         return {\"address\": target_url, \"status\": \"failed\", \"details\": \"Connection Refused\"}\n    except Exception as e:\n         return {\"address\": target_url, \"status\": \"failed\", \"details\": str(e)[:50]}\n\n\n# Scanner Manager to handle concurrency\nclass ScannerManager:\n    def __init__(self):\n        self.is_running = False\n        self.results = []\n    \n    async def run_scan(self, targets: list, concurrency: int = 50, callback=None):\n        self.is_running = True\n        self.results = []\n        \n        sem = asyncio.Semaphore(concurrency)\n        \n        async def worker(ip):\n            async with sem:\n                if not self.is_running: return\n                result = await check_openwrt(ip)\n                # Parse result and enrich\n                result['id'] = len(self.results) + 1\n                self.results.append(result)\n                if callback:\n                    await callback(result)\n                    \n        tasks = [worker(ip) for ip in targets]\n        # Allow cancellation\n        try:\n            await asyncio.gather(*tasks)\n        except Exception:\n            pass\n        finally:\n            self.is_running = False\n"}, {"path": "open-wrt-manager-ui/.gitignore", "content": "# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.\n\n# dependencies\n/node_modules\n\n# next.js\n/.next/\n/out/\n\n# production\n/build\n\n# debug\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n.pnpm-debug.log*\n\n# env files\n.env*\n\n# vercel\n.vercel\n\n# typescript\n*.tsbuildinfo\nnext-env.d.ts"}, {"path": "open-wrt-manager-ui/components.json", "content": "{\n  \"$schema\": \"https://ui.shadcn.com/schema.json\",\n  \"style\": \"new-york\",\n  \"rsc\": true,\n  \"tsx\": true,\n  \"tailwind\": {\n    \"config\": \"\",\n    \"css\": \"app/globals.css\",\n    \"baseColor\": \"neutral\",\n    \"cssVariables\": true,\n    \"prefix\": \"\"\n  },\n  \"aliases\": {\n    \"components\": \"@/components\",\n    \"utils\": \"@/lib/utils\",\n    \"ui\": \"@/components/ui\",\n    \"lib\": \"@/lib\",\n    \"hooks\": \"@/hooks\"\n  },\n  \"iconLibrary\": \"lucide\"\n}\n"}]